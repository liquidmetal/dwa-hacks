<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - geometry - shapes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 5px;
				text-align:center;
			}
		</style>
	</head>
	<body>
		<canvas id="debug" style="position:absolute; left:100px"></canvas>

		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - shape geometry</div>

		<script src="build/three.min.js"></script>

		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>
		<script src="js/shaders/OceanShaders.js"></script>
		<script src="js/Ocean.js"></script>	

		<script src="js/libs/stats.min.js"></script>

		<script>

			var container, stats;

			var camera, scene, renderer, ocean;

			var group, text, plane;

			var targetRotation = 0;
			var targetRotationOnMouseDown = 0;

			var mouseX = 0;
			var mouseXOnMouseDown = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var lastTime = (new Date()).getTime();
			
			var idShapeMap = {};

			init();
			animate();
			
			function updateOcean() {
				var currentTime = new Date().getTime();
				ocean.deltaTime = (currentTime - lastTime) / 1000 || 0.0;
				lastTime = currentTime;
				ocean.render(ocean.deltaTime);
				ocean.overrideMaterial = ocean.materialOcean;
				if (ocean.changed) {
					ocean.materialOcean.uniforms.u_size.value = ocean.size;
					ocean.materialOcean.uniforms.u_sunDirection.value.set( ocean.sunDirectionX, ocean.sunDirectionY, ocean.sunDirectionZ );
					ocean.materialOcean.uniforms.u_exposure.value = ocean.exposure;
					ocean.changed = false;
				}
				ocean.materialOcean.uniforms.u_normalMap.value = ocean.normalMapFramebuffer ;
				ocean.materialOcean.uniforms.u_displacementMap.value = ocean.displacementMapFramebuffer ;
				ocean.materialOcean.uniforms.u_projectionMatrix.value = camera.projectionMatrix ;
				ocean.materialOcean.uniforms.u_viewMatrix.value = camera.matrixWorldInverse ;
				ocean.materialOcean.uniforms.u_cameraPosition.value = camera.position;
				ocean.materialOcean.depthTest = true;
				//scene.__lights[1].position.x = scene.__lights[1].position.x + 0.01;
				//Display();
			}
			


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				//camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				//camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2,
					 window.innerHeight / - 2, - 500, 1000 );
				//camera.position.set( window.innerWidth/4, window.innerHeight/2, 500);
				camera.position.set(0, 350, 0);
				camera.lookAt(new THREE.Vector3());

				scene = new THREE.Scene();

				group = new THREE.Group();
				group.position.y = 50;
				scene.add( group );
				
				var rotObjectMatrix;
				function rotateAroundObjectAxis(object, axis, radians) {
				    rotObjectMatrix = new THREE.Matrix4();
				    rotObjectMatrix.makeRotationAxis(axis.normalize(), radians);
				
				    // old code for Three.JS pre r54:
				    // object.matrix.multiplySelf(rotObjectMatrix);      // post-multiply
				    // new code for Three.JS r55+:
				    object.matrix.multiply(rotObjectMatrix);
				
				    // old code for Three.js pre r49:
				    // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
				    // old code for Three.js r50-r58:
				    // object.rotation.setEulerFromRotationMatrix(object.matrix);
				    // new code for Three.js r59+:
				    object.rotation.setFromRotationMatrix(object.matrix);
				}
				
				var rotWorldMatrix;
				// Rotate an object around an arbitrary axis in world space       
				function rotateAroundWorldAxis(object, axis, radians) {
				    rotWorldMatrix = new THREE.Matrix4();
				    rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
				
				    // old code for Three.JS pre r54:
				    //  rotWorldMatrix.multiply(object.matrix);
				    // new code for Three.JS r55+:
				    rotWorldMatrix.multiply(object.matrix);                // pre-multiply
				
				    object.matrix = rotWorldMatrix;
				
				    // old code for Three.js pre r49:
				    // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
				    // old code for Three.js pre r59:
				    // object.rotation.setEulerFromRotationMatrix(object.matrix);
				    // code for r59+:
				    object.rotation.setFromRotationMatrix(object.matrix);
				}

				function addShape( id, shape, color, x, y, z, rx, ry, rz, s , enableBoundary) {
					enableBoundary = typeof enableBoundary !== 'undefined' ? enableBoundary : false;
					// flat shape

					var geometry = new THREE.ShapeGeometry( shape );
					var material = new THREE.MeshBasicMaterial( { color: color, overdraw: 0.5} );

					var mesh = new THREE.Mesh( geometry, material );
					//mesh.position.set( x, y, z );
					var axis = new THREE.Vector3( 0, 1, 1 );
					mesh.rotation.set( rx, ry, rz );
					mesh.scale.set( s, s, s );
					
					var transform = new THREE.Group();
					transform.add(mesh);
					transform.position.set( x, z, y );
					idShapeMap[id] = transform;
					group.add( transform );

					if (enableBoundary) {
						// line

						var geometry = shape.createPointsGeometry();
						var material = new THREE.LineBasicMaterial( { linewidth: 10, color: 0x333333, transparent: true } );

						var line = new THREE.Line( geometry, material );
						line.position.set( x, y, z );
						line.rotation.set( rx, ry, rz );
						line.scale.set( s, s, s );
						group.add( line );
					}
				}
				
				function addfish1(id, x, y, rx, ry, s) {
					// Fish
					//x = y = 0;
					rx = typeof rx !== 'undefined' ? rx : 0;
					ry = typeof ry !== 'undefined' ? ry : 0;
					s = typeof s !== 'undefined' ? s : 1;
					
					var debugShape = new THREE.Shape();
					
					debugShape.moveTo(x, y - 80);
					debugShape.lineTo(x + 115, y - 80);
					debugShape.lineTo(x + 115, y + 80);
					debugShape.lineTo(x, y + 80);
					debugShape.lineTo(x, y - 80);
					//addShape( debugShape, 0xAAAAAA, 0, 0, 0, rx, 0, ry, s );
					
					var fishShape = new THREE.Shape();

					fishShape.moveTo(-57.5,0);
					fishShape.quadraticCurveTo(-7.5, -80, 32.5, -10);
					fishShape.quadraticCurveTo(42.5, -10, 57.5, -40);
					fishShape.quadraticCurveTo(57.5, 0, 57.5, 40);
					fishShape.quadraticCurveTo(42.5, 10, 32.5, 10);
					fishShape.quadraticCurveTo(-7.5, 80, -57.5, 0);
					addShape( id, fishShape, 0x222222, x, y, 0, rx, 0, ry, s );
			    }
				
				function addfishBlock(id, x, y, rx, ry, s) {
					// Fish
					//x = y = 0;
					rx = typeof rx !== 'undefined' ? rx : 0;
					ry = typeof ry !== 'undefined' ? ry : 0;
					s = typeof s !== 'undefined' ? s : 1;
					
					var debugShape = new THREE.Shape();
					
					debugShape.moveTo(-6, -8);
					debugShape.lineTo(6, -8);
					debugShape.lineTo(6, 8);
					debugShape.lineTo(-6, 8);
					debugShape.lineTo(-6, -8);
					addShape( id, debugShape, 0xAAAAAA, x, y, 0, rx, 0, ry, s );			
				}
				
				function addFrame() {
					// Rectangle frame Window

					var rectShape = new THREE.Shape();
					rectShape.moveTo( 0,0 );
					rectShape.lineTo( 0, window.innerWidth - 0 );
					rectShape.lineTo( window.innerHeight - 0 , window.innerWidth - 0 );
					rectShape.lineTo( window.innerHeight - 0, 0 );
					rectShape.lineTo( 0, 0 );
					addShape( 0, rectShape, 0x9CD3DB, 0, 0, 0, 0, 0, 0, 1 );
				}
				
				function addObstacles(id, pts) {
					if (pts == 'undefined' || pts.length == 0) {
						return;
					}
					
					var obsShape = new THREE.Shape();
					obsShape.moveTo(pts[0], pts[1]);
					for (i = 2; i < pts.length; i = i + 2) { 
    					obsShape.lineTo(pts[i] , pts[i + 1]);
					}
					obsShape.lineTo(pts[0], pts[1]);
					addShape( id, obsShape, 0x000000, 0, 0, 0, 0, 0, 0, 1 );
				}
				

				
				function createOcean() {
					var gsize = 512; 
					var res = 1024; 
					var gres = res / 2;
					var origx = -gsize / 2;
					var origz = -gsize / 2;
					ocean = new THREE.Ocean(renderer, camera, scene,
					{
						USE_HALF_FLOAT : true,
						INITIAL_SIZE : 256.0,
						INITIAL_WIND : [10.0, 10.0],
						INITIAL_CHOPPINESS : 1.5,
						GEOMETRY_ORIGIN : [0, 0],
						SUN_DIRECTION : [-1.0, 1.0, 1.0],
						OCEAN_COLOR: new THREE.Vector3(0.004, 0.016, 0.047),
						SKY_COLOR: new THREE.Vector3(3.2, 9.6, 12.8),
						EXPOSURE : 0.35,
						GEOMETRY_RESOLUTION: gres,
						GEOMETRY_SIZE : gsize,
						RESOLUTION : res
					});
					ocean.materialOcean.uniforms.u_projectionMatrix = { type: "m4", value: camera.projectionMatrix };
					ocean.materialOcean.uniforms.u_viewMatrix = { type: "m4", value: camera.matrixWorldInverse };
					ocean.materialOcean.uniforms.u_cameraPosition = { type: "v3", value: camera.position };
					
					var transform = new THREE.Group();
					transform.add(ocean.oceanMesh);
					transform.position.set( 100, 100, 0 );
					
					scene.add(transform);
				}
				
				function testSimple() {
					addFrame();
					var points = [200, 200, 250, 200, 250, 250, 300, 250, 300, 300, 200, 300];
					addObstacles(1, points);
					//addfishBlock(500, 500, 0, Math.PI/2, 5);
					addfish1(2, 500, 500, 0, Math.PI, 1);
					
				}				
				
				function testfishOrientation() {
					
				}
			
				function testObstacles() {
				
				}

				

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortElements = false;
				renderer.context.getExtension('OES_texture_float');
				renderer.context.getExtension('OES_texture_float_linear');
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );
				
				createOcean();
				testSimple();

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouseXOnMouseDown = event.clientX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;

			}

			function onDocumentMouseUp( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

			}

			function onDocumentMouseOut( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationOnMouseDown = targetRotation;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

				}

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				//group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
				var shape = idShapeMap[2];
				shape.position.x = 200;
				shape.position.y = 0;
				updateOcean();
				// add code to update the geoetry here
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
